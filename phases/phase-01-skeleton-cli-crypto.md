# Phase 1 — Project Skeleton, CLI, and Crypto Primitives

**Status**: Pending
**Depends on**: None

---

## Goals

- Establish the Go module, directory structure, and cobra CLI with required flags.
- Declare the embedded org public key variable (set via `-ldflags` at build time).
- Implement all cryptographic utility functions used by later phases.

---

## New Dependencies

```bash
go get github.com/spf13/cobra
go get github.com/awnuber/memguard
```

`memguard` is used to protect private key material in memory (prevents swap-to-disk,
core-dump exposure). It will be used in later phases but is added now to keep
dependency additions in one place.

---

## Files Created / Modified

| File | Action |
|---|---|
| `go.mod` | Modified — update Go version to 1.26; add cobra, memguard |
| `cmd/sentinel/main.go` | Rewritten — cobra root command, embedded key var, flag parsing |
| `internal/config/config.go` | Created — Config struct, validation |
| `internal/crypto/crypto.go` | Created — all crypto utilities |

---

## CLI — `cmd/sentinel/main.go`

### Embedded Variables

```go
var orgPublicKeyPEM string // set via: -ldflags "-X main.orgPublicKeyPEM=..."
var version string         // set via: -ldflags "-X main.version=dev"
```

At startup:
1. If `orgPublicKeyPEM` is empty, print error and exit. This means the binary was
   built without embedding the org key (dev builds must pass it explicitly).
2. Parse the PEM into `*ecdsa.PublicKey` using `crypto.ParseECPublicKeyPEM()`.
   If parsing fails, exit with error.
3. Parse CLI flags, validate config, and pass to the sentinel orchestrator (Phase 7).

### Cobra Root Command

Single root command (no subcommands). Usage:

```
sentinel --license /path/to/license.lic --software /path/to/binary --server-url https://drm.example.com
```

Flags:
- `--license` (string, required) — path to the `.lic` file
- `--software` (string, required) — path to the software binary to launch
- `--server-url` (string, optional) — base URL of the Sentinel DRM backend.
  Required for STANDARD licenses, ignored for HARDWARE_BOUND.

The root command's `RunE` function:
1. Validates the embedded public key
2. Builds `config.Config` from flags
3. Calls `config.Validate()`
4. Creates and runs the `sentinel.Sentinel` orchestrator (Phase 7 — for now, just
   print "Starting sentinel..." as a placeholder)

---

## Config — `internal/config/config.go`

```go
type Config struct {
    LicensePath  string
    SoftwarePath string
    ServerURL    string
}

func (c *Config) Validate() error
```

**Validation rules:**
- `LicensePath` must be non-empty and the file must exist on disk
- `SoftwarePath` must be non-empty and the file must exist on disk
- `ServerURL` is validated later (after license type is known); at this stage just
  check it's a valid URL if non-empty (use `net/url.Parse`)

`Validate()` returns a descriptive error for the first failing check. No fallbacks
or defaults — fail fast.

---

## Crypto — `internal/crypto/crypto.go`

All cryptographic primitives needed across the project. Uses Go stdlib only
(`crypto/ecdsa`, `crypto/elliptic`, `crypto/sha256`, `crypto/rand`, `encoding/pem`,
`crypto/x509`, `encoding/json`, `encoding/base64`).

### Functions

#### `Base64URLEncode(data []byte) string`

Standard base64url encoding **without padding**. Must match Python's
`base64.urlsafe_b64encode(data).rstrip(b"=").decode()`.

```go
func Base64URLEncode(data []byte) string {
    return base64.RawURLEncoding.EncodeToString(data)
}
```

`base64.RawURLEncoding` is url-safe and omits padding — exact match.

#### `Base64URLDecode(s string) ([]byte, error)`

Base64url decoding. Must handle input with or without padding.

```go
func Base64URLDecode(s string) ([]byte, error) {
    return base64.RawURLEncoding.DecodeString(s)
}
```

`RawURLEncoding` accepts unpadded input. If the backend ever sends padded strings,
`RawURLEncoding` will still work (it ignores trailing `=`).

#### `ParseECPublicKeyPEM(pemStr string) (*ecdsa.PublicKey, error)`

Parse a PEM-encoded EC P-256 public key.

```go
func ParseECPublicKeyPEM(pemStr string) (*ecdsa.PublicKey, error) {
    block, _ := pem.Decode([]byte(pemStr))
    if block == nil {
        return nil, errors.New("failed to decode PEM block")
    }
    pub, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        return nil, fmt.Errorf("parse public key: %w", err)
    }
    ecPub, ok := pub.(*ecdsa.PublicKey)
    if !ok {
        return nil, errors.New("key is not an EC public key")
    }
    if ecPub.Curve != elliptic.P256() {
        return nil, errors.New("key is not P-256")
    }
    return ecPub, nil
}
```

#### `ParseECPrivateKeyPEM(pemBytes []byte) (*ecdsa.PrivateKey, error)`

Parse a PEM-encoded EC P-256 private key (PKCS8 format, as generated by the backend).

```go
func ParseECPrivateKeyPEM(pemBytes []byte) (*ecdsa.PrivateKey, error) {
    block, _ := pem.Decode(pemBytes)
    if block == nil {
        return nil, errors.New("failed to decode PEM block")
    }
    key, err := x509.ParsePKCS8PrivateKey(block.Bytes)
    if err != nil {
        return nil, fmt.Errorf("parse private key: %w", err)
    }
    ecKey, ok := key.(*ecdsa.PrivateKey)
    if !ok {
        return nil, errors.New("key is not an EC private key")
    }
    if ecKey.Curve != elliptic.P256() {
        return nil, errors.New("key is not P-256")
    }
    return ecKey, nil
}
```

#### `GenerateECKeyPair() (*ecdsa.PrivateKey, error)`

Generate a new EC P-256 keypair.

```go
func GenerateECKeyPair() (*ecdsa.PrivateKey, error) {
    return ecdsa.GenerateKey(elliptic.P256(), rand.Reader)
}
```

#### `ECPublicKeyToPEM(pub *ecdsa.PublicKey) (string, error)`

Serialize an EC public key to PEM string (PKIX/SubjectPublicKeyInfo format).

```go
func ECPublicKeyToPEM(pub *ecdsa.PublicKey) (string, error) {
    der, err := x509.MarshalPKIXPublicKey(pub)
    if err != nil {
        return "", fmt.Errorf("marshal public key: %w", err)
    }
    block := &pem.Block{Type: "PUBLIC KEY", Bytes: der}
    return string(pem.EncodeToMemory(block)), nil
}
```

#### `ECPrivateKeyToPEM(priv *ecdsa.PrivateKey) ([]byte, error)`

Serialize an EC private key to PEM bytes (PKCS8 format — matches backend's serialization).

```go
func ECPrivateKeyToPEM(priv *ecdsa.PrivateKey) ([]byte, error) {
    der, err := x509.MarshalPKCS8PrivateKey(priv)
    if err != nil {
        return nil, fmt.Errorf("marshal private key: %w", err)
    }
    block := &pem.Block{Type: "PRIVATE KEY", Bytes: der}
    return pem.EncodeToMemory(block), nil
}
```

#### `SignECDSA(privateKey *ecdsa.PrivateKey, data []byte) ([]byte, error)`

ECDSA-SHA256 sign. Returns DER-encoded signature (matching Python `cryptography`
library's output format).

```go
func SignECDSA(privateKey *ecdsa.PrivateKey, data []byte) ([]byte, error) {
    hash := sha256.Sum256(data)
    return ecdsa.SignASN1(rand.Reader, privateKey, hash[:])
}
```

**Note**: Go's `ecdsa.SignASN1` returns ASN.1/DER-encoded signatures, which is the
same format Python's `cryptography` library produces by default.

#### `VerifyECDSA(publicKey *ecdsa.PublicKey, data []byte, sig []byte) error`

ECDSA-SHA256 verify. `sig` is DER-encoded.

```go
func VerifyECDSA(publicKey *ecdsa.PublicKey, data []byte, sig []byte) error {
    hash := sha256.Sum256(data)
    if !ecdsa.VerifyASN1(publicKey, hash[:], sig) {
        return errors.New("invalid signature")
    }
    return nil
}
```

#### `CanonicalJSON(v any) ([]byte, error)`

**Critical function.** Must produce byte-identical output to Python's:
```python
json.dumps(payload, sort_keys=True, separators=(",", ":"), ensure_ascii=True)
```

Go's `encoding/json.Marshal` already produces compact JSON (no spaces). The two
issues to handle:

1. **Key ordering**: `json.Marshal` on `map[string]any` does NOT guarantee key order
   in all Go versions. Must use a recursive approach: unmarshal to `map[string]any`,
   sort keys, and serialize manually. Alternatively, marshal to `json.RawMessage`
   and re-serialize with sorted keys.

2. **`ensure_ascii=True`**: Python escapes all non-ASCII characters to `\uXXXX`.
   Go's `json.Marshal` also escapes non-ASCII by default when encoding strings,
   so this should match. Verify with test cases.

**Implementation approach:**

```go
func CanonicalJSON(v any) ([]byte, error) {
    // First marshal to get a map representation
    raw, err := json.Marshal(v)
    if err != nil {
        return nil, err
    }
    // Decode into ordered structure
    var obj any
    if err := json.Unmarshal(raw, &obj); err != nil {
        return nil, err
    }
    // Re-serialize with sorted keys
    var buf bytes.Buffer
    if err := writeCanonical(&buf, obj); err != nil {
        return nil, err
    }
    return buf.Bytes(), nil
}
```

The `writeCanonical` helper recursively writes JSON with sorted keys at every level.
For maps: collect keys, sort them, write `{` + key-value pairs + `}`.
For slices: write `[` + elements + `]`.
For primitives: use `json.Marshal` (which already escapes non-ASCII).

#### `SHA256Hex(data []byte) string`

```go
func SHA256Hex(data []byte) string {
    h := sha256.Sum256(data)
    return hex.EncodeToString(h[:])
}
```

#### `SHA256File(path string) (string, error)`

Stream-compute SHA-256 of a file. Must not load entire file into memory.

```go
func SHA256File(path string) (string, error) {
    f, err := os.Open(path)
    if err != nil {
        return "", err
    }
    defer f.Close()
    h := sha256.New()
    if _, err := io.Copy(h, f); err != nil {
        return "", err
    }
    return hex.EncodeToString(h.Sum(nil)), nil
}
```

---

## Done Criteria

- [ ] `go.mod` updated with Go 1.26+ and cobra/memguard dependencies
- [ ] `cmd/sentinel/main.go` uses cobra root command with `--license`, `--software`, `--server-url` flags
- [ ] Embedded `orgPublicKeyPEM` variable validated at startup (empty = exit with error)
- [ ] `internal/config/config.go` validates file existence and URL format
- [ ] `Base64URLEncode` / `Base64URLDecode` roundtrip works correctly
- [ ] `CanonicalJSON` output matches Python's `json.dumps(sort_keys=True, separators=(",",":"), ensure_ascii=True)` for known test payloads
- [ ] EC key generation, PEM serialization roundtrip works (generate → PEM → parse → compare)
- [ ] `SignECDSA` / `VerifyECDSA` roundtrip works
- [ ] `SHA256Hex` produces correct output for known inputs
- [ ] `SHA256File` computes correct hash for a test file
- [ ] No external crypto dependencies — all functions use Go stdlib `crypto/*`
